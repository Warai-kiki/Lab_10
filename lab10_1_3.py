'''
Реалізувати програмно мовою Python завдання з наведеного нижче списку. Для
кожної з задач алгоритм реалізувати з використанням рекурсії і ітерації. Аргументувати
письмово доцільність вибору в кожному випадку рекурсії або ітерації (використовувати
в якості критеріїв - час розробки та виконання програм, обсяг займаної пам'яті,
читабельність програми).
1. Сформувати функцію, що буде обчислювати факторіал заданого користувачем
натурального числа n.
2. Сформувати функцію для обчислення цифрового кореню натурального числа.
Цифровий корінь отримується наступним чином: необхідно скласти всі цифри заданого
числа, потім скласти всі цифри знайденої суми і повторювати процес до тих пір, поки
сума не буде дорівнювати однозначному числу, що і буде цифровим коренем заданого
числа.
3. Сформувати функцію для обчислення індексу максимального елемента масиву
n*n, де 1<=n<=5.
Котулич К.А. 122А
'''
import numpy as np
from random import randint
# 1 краще використовувати рекурсію, так як зберігання попередніх значень значень всеодно необхідне, а так можна зекономити час
def fact_r(x): # рекурсивний метод
    if x==1: # якщо це факторіал від одиниці зрозуміло яке буде значення
        return 1
    else:
        return fact_r(x-1)*x # якщо інші числа використовуємо формулу з викликом самої функції
def fact_i(x): # ітераційний спосіб
    f = 1
    for i in range(1,x+1): # перебираємо всі число факторіалу і множимо кожне з ни х на добуток попередніх чисел
        f *= i
    return f
n = int(input('Введіть факторіал: '))
print(f'{fact_r(n)}\n{fact_i(n)}') # викликаємо наші функції
#
def num_r(y): # рекурсивний метод
    if y<10: #
        return y
    else:
        return y%10+num_r(y//10) #
def num_i(y): # ітераційний спосіб
    b = y%10
    while y>=10: #
        b+=(y%100)//10
        y = y//10
    return b
m = int(input())
print(f'{num_r(m)}\n{num_i(m)}') # викликаємо наші функції
'''# 3 краще використовувати ітераційний метод, адже вирішення через екцрсію занадто заплутане, займе багато памяті та часу
def max_r(i,j): # рекурсивний метод (не працює)
    z = np.array([[randint(-20, 20) for k in range(i)] for l in range(j)]) # створюємо масив потрібної розмірності
    o = i
    def max_r1(i,j): # вводимо ще одну функцію щоб кожен раз не виводити новий масив
        nonlocal z,o 
        h = 0
        k = 0
        if j>0: # ця програма мала порівнювати числа в одному рядку, зменшуючи кількість стовпців
            if i>0: # а потім переходити на наступний рядок і робити те саме
                if z[0][0]>z[i][j]:
                    h = 0
                    k = 0
                else:
                    h = i
                    k = j
            else:
                i = o
        return max_r1(k,h)
    return max_r1()
'''
def max_i(i,j): # ітераційний спосіб
    z = np.array([[randint(-20,20) for k in range(i)] for l in range(j)]) # створюємо масив потрібної розмірності
    print(z)
    for h in range(i): # перебираємо елементи масиву
        for p in range(j):
            if z[h][p]==z.max(): # знаходимо який елемент відповідає максимальному
                return h,p # виводимо його індекс
n = int(input())
z = np.array([[randint(-20, 20) for k in range(n)] for l in range(n)])
print(z)
#print(max_r(n,n)) # викликаємо наші функції
print(max_i(n,n))
