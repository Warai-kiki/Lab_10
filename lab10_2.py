'''
Реалізувати програмно мовою Python завдання з наведеного нижче списку. Для
кожної з задач алгоритм реалізувати з використанням рекурсії і ітерації. Аргументувати
письмово доцільність вибору в кожному випадку рекурсії або ітерації (використовувати
в якості критеріїв - час розробки та виконання програм, обсяг займаної пам'яті,
читабельність програми).
1. Сформувати функцію для введення з клавіатури послідовності чисел і виведення
її на екран у зворотному порядку (завершаючий символ послідовності – крапка)
2. Сформувати функцію, що визначатиме чи є задане натуральне число простим.
Простим називається число, що більше за 1 та не має інших дільників, окрім 1 та самого
себе).
3. Сформувати функцію для переведення натурального числа з десяткової системи
числення у с.
Котулич К.А. 122А
'''
import sys
import math

# 1 для подібнх задач варто використовувати ітераційний спосіб, адже є вбудована функція; це зекономиь час та пам'ять
def posl_r(p,*x): # рекурсивний метод
    d = []
    if p>=0: # поки довжина масиву більша нуля
        d.append(x[p-1]) # додаємо останній елемент до списку
        return posl_r(p-1,*x) # викликаємо цю функцію мовнно зменшючи довжину, тим самим додається кожен елемент по черзі
    else:
        s = ','.join(d) # переводимо список в строку
        return s
k = input('').split()
j = len(k)
def posl_i(): # ітераційний спосіб
    n = input().split() # створюємо список з чисел
    n.reverse() # розвертаємо його
    v = ','.join(n) # переодимо в строку
    return v
print(f'{posl_r(j,*k)}.\n{posl_i()}.') # викликаємо наші функції
#
def pr_r(y,i=2): # рекурсивний метод
    if y==2: # якщо це 2 то точно просте
        return 'YES'
    elif y<2: # якщо менше то ні
        return 'NO'
    else: # усі інші числа перевіряються
        if y%i==0: # яко знаходиться ще один дільник то ні
            return 'NO'
        else:
            pr_r(y,i+1) # якщо цей дільник не підходить знову викликається функція але для наступного дільникаа
        return 'YES'
def pr_i(y): # ітераційний спосіб
    if y==2: # якщо це 2 то точно просте
        return 'YES'
    elif y<2: # якщо менше то ні
        return 'NO'
    else:# усі інші числа перевіряються
        i=2 # лічильник
        while i<= math.sqrt(y): # поки лічилльник менше кореня з нашого числа
            if y%i==0: # перевяємо чи дане значення є дільником
                return 'NO'
            i+=1 # збільшуємо лічильник і перевіряємо наступне значення
        return 'YES'
n = int(input('Введіть число, щоб перевірити чи просте воно: '))
print(pr_r(n)) # викликаємо наші функції
print(pr_i(n))
# 3 в даному типі звадач краще використовувати ітераційний метод, адже рекурсивний метод
# вимагає великої глибини рекурсії, через що виконується довго і займає багато пам'яті
def num_r(z): # рекурсивний метод (правильно обраховує числа менші за 31)
    hexdig = '0123456789ABCDEF'
    hexdig.split() # створюємо список з усіма значеннями шістнадцятирічної системи
    t = list()
    ost = z % 16 # обраховуємо остачу
    if z//16>1: # <-якщо
        t.append(hexdig[ost]) # то до списку додається лишеостача
        num_r(z // 16) # знову викликаємо нашу функцію
    else:
        t.append(hexdig[ost]) # в інших випадках додаємо остачу
        t.append('1') # та 1
    t.reverse()
    t1 = ''.join(t) # розвертаємо список і виводимо в якості строки
    return t1
def num_i(z): # ітераційний спосіб
    x = hex(z) # використовуємо вбудовану функцію
    return x
sys.setrecursionlimit(2000) # коректуємо ліміт рекурсії
b = int(input('Введіть число яее хочете перевести: '))
print(num_r(b)) # викликаємо наші функції
print(num_i(b))
